using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace VPM.Services
{
    /// <summary>
    /// High-performance binary cache for Hub resources (packages.json).
    /// Implements HTTP conditional requests (ETag/Last-Modified) for efficient incremental updates.
    /// Stores cached data in the same folder as other VPM caches for consistency.
    /// 
    /// Features:
    /// - Binary serialization for fast load/save (5-10x faster than JSON)
    /// - HTTP conditional requests to minimize bandwidth
    /// - Automatic cache validation and refresh
    /// - Thread-safe operations using simple locking
    /// - Statistics tracking for monitoring
    /// </summary>
    public class HubResourcesCache : IDisposable
    {
        private const int CACHE_VERSION = 1;
        private const string CACHE_MAGIC = "VPMH"; // VPM Hub cache
        
        private readonly string _cacheDirectory;
        private readonly string _cacheFilePath;
        private readonly string _metadataFilePath;
        private readonly object _lock = new object(); // Simple lock instead of ReaderWriterLockSlim
        private readonly HttpClient _httpClient;
        private bool _disposed;
        
        // Cached data
        private Dictionary<string, string> _packageIdToResourceId;
        private Dictionary<string, int> _packageGroupToLatestVersion;
        private DateTime _lastLoadTime = DateTime.MinValue;
        private bool _isLoaded = false;
        
        // HTTP caching metadata
        private string _etag;
        private DateTime _lastModified = DateTime.MinValue;
        private DateTime _cacheFileTime = DateTime.MinValue;
        
        // Statistics
        private int _cacheHits = 0;
        private int _cacheMisses = 0;
        private int _conditionalHits = 0; // 304 Not Modified responses
        private int _fullRefreshes = 0;   // Full downloads
        private long _bytesDownloaded = 0;
        private long _bytesSaved = 0;     // Bytes saved by conditional requests
        
        // Configuration
        private readonly TimeSpan _staleCheckInterval = TimeSpan.FromMinutes(30);
        private readonly TimeSpan _maxCacheAge = TimeSpan.FromDays(7);
        
        public HubResourcesCache(HttpClient httpClient = null)
        {
            // Use AppData for cache storage (same folder as metadata and image caches)
            var appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
            _cacheDirectory = Path.Combine(appDataPath, "VPM", "Cache");
            _cacheFilePath = Path.Combine(_cacheDirectory, "HubResources.cache");
            _metadataFilePath = Path.Combine(_cacheDirectory, "HubResources.meta");
            
            _httpClient = httpClient;
            
            try
            {
                if (!Directory.Exists(_cacheDirectory))
                {
                    Directory.CreateDirectory(_cacheDirectory);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[HubResourcesCache] Failed to create cache directory: {ex.Message}");
            }
            
            _packageIdToResourceId = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            _packageGroupToLatestVersion = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        }
        
        #region Public Properties
        
        /// <summary>
        /// Gets whether the cache has been loaded
        /// </summary>
        public bool IsLoaded => _isLoaded;
        
        /// <summary>
        /// Gets the number of packages in the cache
        /// </summary>
        public int PackageCount
        {
            get
            {
                lock (_lock)
                {
                    return _packageIdToResourceId?.Count ?? 0;
                }
            }
        }
        
        /// <summary>
        /// Gets the cache directory path
        /// </summary>
        public string CacheDirectory => _cacheDirectory;
        
        /// <summary>
        /// Gets the cache file path
        /// </summary>
        public string CacheFilePath => _cacheFilePath;
        
        /// <summary>
        /// Gets the last time the cache was loaded
        /// </summary>
        public DateTime LastLoadTime => _lastLoadTime;
        
        /// <summary>
        /// Gets the ETag from the last successful fetch
        /// </summary>
        public string ETag => _etag;
        
        /// <summary>
        /// Gets the Last-Modified date from the last successful fetch
        /// </summary>
        public DateTime LastModified => _lastModified;
        
        #endregion
        
        #region Cache Loading
        
        /// <summary>
        /// Loads the cache from disk. Returns true if cache was loaded successfully.
        /// </summary>
        public bool LoadFromDisk()
        {
            if (!File.Exists(_cacheFilePath))
            {
                Debug.WriteLine("[HubResourcesCache] No cache file found");
                return false;
            }
            
            try
            {
                var sw = Stopwatch.StartNew();
                
                // Load metadata first (outside lock - it's a separate file)
                LoadMetadata();
                
                // Read file into memory first, then parse (minimizes lock time)
                byte[] fileData;
                try
                {
                    fileData = File.ReadAllBytes(_cacheFilePath);
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"[HubResourcesCache] Failed to read cache file: {ex.Message}");
                    return false;
                }
                
                using var stream = new MemoryStream(fileData);
                using var reader = new BinaryReader(stream);
                
                // Read and validate header
                var magic = Encoding.ASCII.GetString(reader.ReadBytes(4));
                if (magic != CACHE_MAGIC)
                {
                    Debug.WriteLine("[HubResourcesCache] Invalid cache magic");
                    return false;
                }
                
                var version = reader.ReadInt32();
                if (version != CACHE_VERSION)
                {
                    Debug.WriteLine($"[HubResourcesCache] Cache version mismatch: {version} != {CACHE_VERSION}");
                    return false;
                }
                
                // Read cache timestamp
                var cacheTicks = reader.ReadInt64();
                var cacheFileTime = new DateTime(cacheTicks);
                
                // Check if cache is too old
                if (DateTime.Now - cacheFileTime > _maxCacheAge)
                {
                    Debug.WriteLine("[HubResourcesCache] Cache is too old, needs refresh");
                    return false;
                }
                
                // Read package count
                var packageCount = reader.ReadInt32();
                if (packageCount < 0 || packageCount > 500000) // Sanity check
                {
                    Debug.WriteLine($"[HubResourcesCache] Invalid package count: {packageCount}");
                    return false;
                }
                
                // Parse all data before acquiring lock
                var packageIdToResourceId = new Dictionary<string, string>(packageCount, StringComparer.OrdinalIgnoreCase);
                var packageGroupToLatestVersion = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
                
                for (int i = 0; i < packageCount; i++)
                {
                    var packageName = reader.ReadString();
                    var resourceId = reader.ReadString();
                    
                    packageIdToResourceId[packageName] = resourceId;
                    
                    // Build version index
                    var ver = ExtractVersion(packageName);
                    var groupName = GetPackageGroupName(packageName);
                    
                    if (ver >= 0 && !string.IsNullOrEmpty(groupName))
                    {
                        if (!packageGroupToLatestVersion.TryGetValue(groupName, out var currentLatest) || ver > currentLatest)
                        {
                            packageGroupToLatestVersion[groupName] = ver;
                        }
                    }
                }
                
                // Now acquire lock and swap in the new data
                lock (_lock)
                {
                    _packageIdToResourceId = packageIdToResourceId;
                    _packageGroupToLatestVersion = packageGroupToLatestVersion;
                    _cacheFileTime = cacheFileTime;
                    _isLoaded = true;
                    _lastLoadTime = DateTime.Now;
                    _cacheHits++;
                }
                
                sw.Stop();
                Debug.WriteLine($"[HubResourcesCache] Loaded {packageCount} packages from cache in {sw.ElapsedMilliseconds}ms");
                
                return true;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[HubResourcesCache] Failed to load cache: {ex.Message}");
                _cacheMisses++;
                return false;
            }
        }
        
        /// <summary>
        /// Loads the cache asynchronously from disk
        /// </summary>
        public Task<bool> LoadFromDiskAsync()
        {
            return Task.Run(() => LoadFromDisk());
        }
        
        /// <summary>
        /// Loads HTTP caching metadata (ETag, Last-Modified) from disk
        /// </summary>
        private void LoadMetadata()
        {
            if (!File.Exists(_metadataFilePath))
                return;
            
            try
            {
                using var reader = new BinaryReader(File.OpenRead(_metadataFilePath));
                
                var version = reader.ReadInt32();
                if (version != 1)
                    return;
                
                var etag = reader.ReadString();
                _etag = string.IsNullOrEmpty(etag) ? null : etag;
                
                var lastModTicks = reader.ReadInt64();
                _lastModified = lastModTicks > 0 ? new DateTime(lastModTicks) : DateTime.MinValue;
                
                Debug.WriteLine($"[HubResourcesCache] Loaded metadata - ETag: {_etag?.Substring(0, Math.Min(20, _etag?.Length ?? 0))}..., LastModified: {_lastModified}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[HubResourcesCache] Failed to load metadata: {ex.Message}");
                _etag = null;
                _lastModified = DateTime.MinValue;
            }
        }
        
        /// <summary>
        /// Saves HTTP caching metadata to disk
        /// </summary>
        private void SaveMetadata()
        {
            try
            {
                var tempPath = _metadataFilePath + ".tmp";
                
                using (var writer = new BinaryWriter(File.Create(tempPath)))
                {
                    writer.Write(1); // Version
                    writer.Write(_etag ?? "");
                    writer.Write(_lastModified.Ticks);
                }
                
                // Atomic replace
                if (File.Exists(_metadataFilePath))
                    File.Delete(_metadataFilePath);
                File.Move(tempPath, _metadataFilePath);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[HubResourcesCache] Failed to save metadata: {ex.Message}");
            }
        }
        
        #endregion
        
        #region Cache Saving
        
        /// <summary>
        /// Saves the current cache to disk
        /// </summary>
        public bool SaveToDisk()
        {
            try
            {
                var sw = Stopwatch.StartNew();
                var tempPath = _cacheFilePath + ".tmp";
                
                // Copy data under lock, then write outside lock
                Dictionary<string, string> dataCopy;
                lock (_lock)
                {
                    if (_packageIdToResourceId == null || _packageIdToResourceId.Count == 0)
                        return false;
                    
                    dataCopy = new Dictionary<string, string>(_packageIdToResourceId, StringComparer.OrdinalIgnoreCase);
                }
                
                using (var stream = new FileStream(tempPath, FileMode.Create, FileAccess.Write, FileShare.None))
                using (var writer = new BinaryWriter(stream))
                {
                    // Write header
                    writer.Write(Encoding.ASCII.GetBytes(CACHE_MAGIC));
                    writer.Write(CACHE_VERSION);
                    writer.Write(DateTime.Now.Ticks);
                    
                    // Write package count
                    writer.Write(dataCopy.Count);
                    
                    // Write packages
                    foreach (var kvp in dataCopy)
                    {
                        writer.Write(kvp.Key);
                        writer.Write(kvp.Value);
                    }
                    
                    writer.Flush();
                }
                
                // Atomic replace
                if (File.Exists(_cacheFilePath))
                    File.Delete(_cacheFilePath);
                File.Move(tempPath, _cacheFilePath);
                
                // Save metadata
                SaveMetadata();
                
                sw.Stop();
                Debug.WriteLine($"[HubResourcesCache] Saved cache in {sw.ElapsedMilliseconds}ms");
                
                return true;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[HubResourcesCache] Failed to save cache: {ex.Message}");
                
                // Clean up temp file
                try
                {
                    var tempPath = _cacheFilePath + ".tmp";
                    if (File.Exists(tempPath))
                        File.Delete(tempPath);
                }
                catch { }
                
                return false;
            }
        }
        
        /// <summary>
        /// Saves the cache asynchronously
        /// </summary>
        public Task<bool> SaveToDiskAsync()
        {
            return Task.Run(() => SaveToDisk());
        }
        
        #endregion
        
        #region HTTP Fetching with Conditional Requests
        
        /// <summary>
        /// Fetches the packages.json from Hub, using conditional requests if possible.
        /// Returns true if data was updated (either from network or cache is still valid).
        /// </summary>
        public async Task<bool> FetchFromHubAsync(string packagesJsonUrl, CancellationToken cancellationToken = default)
        {
            if (_httpClient == null)
            {
                Debug.WriteLine("[HubResourcesCache] No HttpClient provided, cannot fetch from Hub");
                return false;
            }
            
            try
            {
                var sw = Stopwatch.StartNew();
                
                // Create request with conditional headers
                var request = new HttpRequestMessage(HttpMethod.Get, packagesJsonUrl);
                
                // Add conditional request headers if we have cached data
                if (!string.IsNullOrEmpty(_etag))
                {
                    request.Headers.TryAddWithoutValidation("If-None-Match", _etag);
                }
                
                if (_lastModified > DateTime.MinValue)
                {
                    request.Headers.IfModifiedSince = new DateTimeOffset(_lastModified);
                }
                
                Debug.WriteLine($"[HubResourcesCache] Fetching packages.json (ETag: {_etag?.Substring(0, Math.Min(20, _etag?.Length ?? 0))}...)");
                
                using var response = await _httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cancellationToken);
                
                // Handle 304 Not Modified - cache is still valid
                if (response.StatusCode == HttpStatusCode.NotModified)
                {
                    lock (_lock)
                    {
                        _conditionalHits++;
                        _lastLoadTime = DateTime.Now;
                        
                        // Estimate bytes saved (typical packages.json is ~2-5MB)
                        _bytesSaved += (_packageIdToResourceId?.Count ?? 0) * 50; // Rough estimate
                    }
                    
                    sw.Stop();
                    Debug.WriteLine($"[HubResourcesCache] 304 Not Modified - cache is valid ({sw.ElapsedMilliseconds}ms)");
                    
                    return true;
                }
                
                response.EnsureSuccessStatusCode();
                
                // Read the response
                var jsonContent = await response.Content.ReadAsStringAsync(cancellationToken);
                var contentLength = jsonContent.Length;
                
                // Parse JSON outside of lock
                var packagesJson = JsonDocument.Parse(jsonContent);
                
                var packageIdToResourceId = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                var packageGroupToLatestVersion = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
                
                foreach (var prop in packagesJson.RootElement.EnumerateObject())
                {
                    var packageName = prop.Name.Replace(".var", "");
                    
                    // Handle both string and number resource IDs
                    string resourceId;
                    if (prop.Value.ValueKind == JsonValueKind.String)
                    {
                        resourceId = prop.Value.GetString();
                    }
                    else if (prop.Value.ValueKind == JsonValueKind.Number)
                    {
                        resourceId = prop.Value.GetRawText();
                    }
                    else
                    {
                        resourceId = prop.Value.ToString();
                    }
                    
                    packageIdToResourceId[packageName] = resourceId;
                    
                    // Build version index
                    var version = ExtractVersion(packageName);
                    var groupName = GetPackageGroupName(packageName);
                    
                    if (version >= 0 && !string.IsNullOrEmpty(groupName))
                    {
                        if (!packageGroupToLatestVersion.TryGetValue(groupName, out var currentLatest) || version > currentLatest)
                        {
                            packageGroupToLatestVersion[groupName] = version;
                        }
                    }
                }
                
                // Swap in new data under lock
                lock (_lock)
                {
                    _packageIdToResourceId = packageIdToResourceId;
                    _packageGroupToLatestVersion = packageGroupToLatestVersion;
                    _isLoaded = true;
                    _lastLoadTime = DateTime.Now;
                    _bytesDownloaded += contentLength;
                    _fullRefreshes++;
                }
                
                // Update HTTP caching metadata (outside lock)
                if (response.Headers.ETag != null)
                {
                    _etag = response.Headers.ETag.Tag;
                }
                
                if (response.Content.Headers.LastModified.HasValue)
                {
                    _lastModified = response.Content.Headers.LastModified.Value.UtcDateTime;
                }
                
                // Save to disk asynchronously
                _ = SaveToDiskAsync();
                
                sw.Stop();
                Debug.WriteLine($"[HubResourcesCache] Fetched {packageIdToResourceId.Count} packages ({contentLength / 1024}KB) in {sw.ElapsedMilliseconds}ms");
                
                return true;
            }
            catch (TaskCanceledException)
            {
                Debug.WriteLine("[HubResourcesCache] Fetch cancelled");
                return false;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[HubResourcesCache] Failed to fetch from Hub: {ex.Message}");
                return false;
            }
        }
        
        /// <summary>
        /// Checks if the cache needs to be refreshed based on staleness
        /// </summary>
        public bool NeedsRefresh()
        {
            if (!_isLoaded)
                return true;
            
            if (_lastLoadTime == DateTime.MinValue)
                return true;
            
            return DateTime.Now - _lastLoadTime > _staleCheckInterval;
        }
        
        #endregion
        
        #region Data Access
        
        /// <summary>
        /// Gets the resource ID for a package name
        /// </summary>
        public string GetResourceId(string packageName)
        {
            lock (_lock)
            {
                if (_packageIdToResourceId == null)
                    return null;
                
                _packageIdToResourceId.TryGetValue(packageName.Replace(".var", ""), out var resourceId);
                return resourceId;
            }
        }
        
        /// <summary>
        /// Gets the latest version for a package group
        /// </summary>
        public int GetLatestVersion(string packageGroupName)
        {
            lock (_lock)
            {
                if (_packageGroupToLatestVersion == null)
                    return -1;
                
                if (_packageGroupToLatestVersion.TryGetValue(packageGroupName, out var latestVersion))
                    return latestVersion;
                
                return -1;
            }
        }
        
        /// <summary>
        /// Checks if a package has an update available
        /// </summary>
        public bool HasUpdate(string packageGroupName, int localVersion)
        {
            var hubVersion = GetLatestVersion(packageGroupName);
            return hubVersion > localVersion;
        }
        
        /// <summary>
        /// Gets all unique creator names from the packages index
        /// </summary>
        public List<string> GetAllCreators()
        {
            lock (_lock)
            {
                if (_packageIdToResourceId == null || _packageIdToResourceId.Count == 0)
                    return new List<string>();
                
                var creators = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                
                foreach (var packageName in _packageIdToResourceId.Keys)
                {
                    var firstDot = packageName.IndexOf('.');
                    if (firstDot > 0)
                    {
                        var creator = packageName.Substring(0, firstDot);
                        creators.Add(creator);
                    }
                }
                
                var result = new List<string>(creators);
                result.Sort(StringComparer.OrdinalIgnoreCase);
                return result;
            }
        }
        
        /// <summary>
        /// Gets the package ID to resource ID dictionary (for direct access by HubService)
        /// Returns a copy to avoid threading issues
        /// </summary>
        public Dictionary<string, string> GetPackageIdToResourceId()
        {
            lock (_lock)
            {
                if (_packageIdToResourceId == null)
                    return new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                
                return new Dictionary<string, string>(_packageIdToResourceId, StringComparer.OrdinalIgnoreCase);
            }
        }
        
        /// <summary>
        /// Gets the package group to latest version dictionary (for direct access by HubService)
        /// Returns a copy to avoid threading issues
        /// </summary>
        public Dictionary<string, int> GetPackageGroupToLatestVersion()
        {
            lock (_lock)
            {
                if (_packageGroupToLatestVersion == null)
                    return new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
                
                return new Dictionary<string, int>(_packageGroupToLatestVersion, StringComparer.OrdinalIgnoreCase);
            }
        }
        
        #endregion
        
        #region Statistics
        
        /// <summary>
        /// Gets cache statistics
        /// </summary>
        public HubResourcesCacheStats GetStatistics()
        {
            lock (_lock)
            {
                var cacheSize = 0L;
                try
                {
                    if (File.Exists(_cacheFilePath))
                        cacheSize = new FileInfo(_cacheFilePath).Length;
                }
                catch { }
                
                return new HubResourcesCacheStats
                {
                    PackageCount = _packageIdToResourceId?.Count ?? 0,
                    CacheHits = _cacheHits,
                    CacheMisses = _cacheMisses,
                    ConditionalHits = _conditionalHits,
                    FullRefreshes = _fullRefreshes,
                    BytesDownloaded = _bytesDownloaded,
                    BytesSaved = _bytesSaved,
                    CacheSizeBytes = cacheSize,
                    LastLoadTime = _lastLoadTime,
                    LastModified = _lastModified,
                    ETag = _etag
                };
            }
        }
        
        /// <summary>
        /// Resets statistics counters
        /// </summary>
        public void ResetStatistics()
        {
            lock (_lock)
            {
                _cacheHits = 0;
                _cacheMisses = 0;
                _conditionalHits = 0;
                _fullRefreshes = 0;
                _bytesDownloaded = 0;
                _bytesSaved = 0;
            }
        }
        
        #endregion
        
        #region Cache Management
        
        /// <summary>
        /// Clears the cache from memory and disk
        /// </summary>
        public bool ClearCache()
        {
            try
            {
                lock (_lock)
                {
                    _packageIdToResourceId = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                    _packageGroupToLatestVersion = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
                    _isLoaded = false;
                    _lastLoadTime = DateTime.MinValue;
                    _etag = null;
                    _lastModified = DateTime.MinValue;
                    _cacheFileTime = DateTime.MinValue;
                    
                    _cacheHits = 0;
                    _cacheMisses = 0;
                    _conditionalHits = 0;
                    _fullRefreshes = 0;
                    _bytesDownloaded = 0;
                    _bytesSaved = 0;
                }
                
                // Delete cache files
                if (File.Exists(_cacheFilePath))
                    File.Delete(_cacheFilePath);
                
                if (File.Exists(_metadataFilePath))
                    File.Delete(_metadataFilePath);
                
                // Clean up temp files
                try
                {
                    var tempFiles = Directory.GetFiles(_cacheDirectory, "HubResources*.tmp");
                    foreach (var file in tempFiles)
                    {
                        try { File.Delete(file); } catch { }
                    }
                }
                catch { }
                
                Debug.WriteLine("[HubResourcesCache] Cache cleared");
                return true;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[HubResourcesCache] Failed to clear cache: {ex.Message}");
                return false;
            }
        }
        
        /// <summary>
        /// Gets the total size of the cache files in bytes
        /// </summary>
        public long GetCacheSize()
        {
            try
            {
                long size = 0;
                
                if (File.Exists(_cacheFilePath))
                    size += new FileInfo(_cacheFilePath).Length;
                
                if (File.Exists(_metadataFilePath))
                    size += new FileInfo(_metadataFilePath).Length;
                
                return size;
            }
            catch
            {
                return 0;
            }
        }
        
        #endregion
        
        #region Helper Methods
        
        private static int ExtractVersion(string packageName)
        {
            var name = packageName;
            
            if (name.EndsWith(".var", StringComparison.OrdinalIgnoreCase))
                name = name.Substring(0, name.Length - 4);
            
            if (name.EndsWith(".latest", StringComparison.OrdinalIgnoreCase))
                return -1;
            
            var lastDot = name.LastIndexOf('.');
            if (lastDot > 0)
            {
                var afterDot = name.Substring(lastDot + 1);
                if (int.TryParse(afterDot, out var version))
                    return version;
            }
            
            return -1;
        }
        
        private static string GetPackageGroupName(string packageName)
        {
            var name = packageName;
            
            if (name.EndsWith(".var", StringComparison.OrdinalIgnoreCase))
                name = name.Substring(0, name.Length - 4);
            
            if (name.EndsWith(".latest", StringComparison.OrdinalIgnoreCase))
                name = name.Substring(0, name.Length - 7);
            
            var lastDot = name.LastIndexOf('.');
            if (lastDot > 0)
            {
                var afterDot = name.Substring(lastDot + 1);
                if (int.TryParse(afterDot, out _))
                    return name.Substring(0, lastDot);
            }
            
            return name;
        }
        
        #endregion
        
        #region IDisposable
        
        public void Dispose()
        {
            if (!_disposed)
            {
                _disposed = true;
            }
        }
        
        #endregion
    }
    
    /// <summary>
    /// Statistics for the Hub resources cache
    /// </summary>
    public class HubResourcesCacheStats
    {
        public int PackageCount { get; set; }
        public int CacheHits { get; set; }
        public int CacheMisses { get; set; }
        public int ConditionalHits { get; set; }  // 304 Not Modified responses
        public int FullRefreshes { get; set; }    // Full downloads
        public long BytesDownloaded { get; set; }
        public long BytesSaved { get; set; }      // Bytes saved by conditional requests
        public long CacheSizeBytes { get; set; }
        public DateTime LastLoadTime { get; set; }
        public DateTime LastModified { get; set; }
        public string ETag { get; set; }
        
        /// <summary>
        /// Gets the hit rate percentage
        /// </summary>
        public double HitRate
        {
            get
            {
                var total = CacheHits + CacheMisses;
                return total > 0 ? (CacheHits * 100.0 / total) : 0;
            }
        }
        
        /// <summary>
        /// Gets the conditional hit rate (304 responses vs full downloads)
        /// </summary>
        public double ConditionalHitRate
        {
            get
            {
                var total = ConditionalHits + FullRefreshes;
                return total > 0 ? (ConditionalHits * 100.0 / total) : 0;
            }
        }
        
        /// <summary>
        /// Gets formatted cache size
        /// </summary>
        public string CacheSizeFormatted
        {
            get
            {
                var bytes = CacheSizeBytes;
                if (bytes <= 0) return "0 B";
                
                string[] sizes = { "B", "KB", "MB", "GB" };
                int order = 0;
                double size = bytes;
                while (size >= 1024 && order < sizes.Length - 1)
                {
                    order++;
                    size /= 1024;
                }
                return $"{size:0.##} {sizes[order]}";
            }
        }
        
        /// <summary>
        /// Gets formatted bytes downloaded
        /// </summary>
        public string BytesDownloadedFormatted
        {
            get
            {
                var bytes = BytesDownloaded;
                if (bytes <= 0) return "0 B";
                
                string[] sizes = { "B", "KB", "MB", "GB" };
                int order = 0;
                double size = bytes;
                while (size >= 1024 && order < sizes.Length - 1)
                {
                    order++;
                    size /= 1024;
                }
                return $"{size:0.##} {sizes[order]}";
            }
        }
        
        /// <summary>
        /// Gets formatted bytes saved
        /// </summary>
        public string BytesSavedFormatted
        {
            get
            {
                var bytes = BytesSaved;
                if (bytes <= 0) return "0 B";
                
                string[] sizes = { "B", "KB", "MB", "GB" };
                int order = 0;
                double size = bytes;
                while (size >= 1024 && order < sizes.Length - 1)
                {
                    order++;
                    size /= 1024;
                }
                return $"{size:0.##} {sizes[order]}";
            }
        }
    }
}
